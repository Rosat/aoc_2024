"""
Script to solve an advent of code problem.
"""

# Standard library imports
import os
import logging
import sys
import re
import numpy as np
import itertools
import math


def main():
   script_directory = os.path.dirname(os.path.abspath(__file__))
   _solve_problem(f"{script_directory}/data_small.txt",1)
   _solve_problem(f"{script_directory}/data.txt",1)
   _solve_problem(f"{script_directory}/data_small.txt",2)
   _solve_problem(f"{script_directory}/data.txt",2)

def _check_data(data_file):
   # Ensure that data file exists
   if not os.path.isfile(data_file):
      logging.error("Data file does not exist.")
      sys.exit(1)

   # Ensure that input exists
   if os.path.getsize(data_file) <= 0:
      logging.error("Data file is still empty.")
      sys.exit(1)

def _add_antenna(antennas_per_type,i,j,c):
   """Adding an antenna (i,j,c) to the existing dictionary of antennas"""
   if c == ".":
      return
   if c in antennas_per_type:
      antennas_per_type[c].append([i,j])
   else:
      antennas_per_type[c] = [[i,j]]

list_add = lambda l1,l2 : [x+y for x,y in zip(l1,l2)]
list_dif = lambda l1,l2 : [x-y for x,y in zip(l1,l2)]
list_scal_mul = lambda l,s : [s*x for x in l]
list_scal_div = lambda l,s : [int(x/s) for x in l]
list_iseq = lambda l1,l2 : all([x==y for x,y in zip(l1,l2)])
loc_in_range = lambda loc,x_min,x_max,y_min,y_max : (x_min < loc[0] and loc[0] < x_max and y_min < loc[1] and loc[1] < y_max)

def _antinodes_from_locations_part1(locs):
   """Returns the list of antinodes generated by all pairs of locations given as input (as defined in part 1)"""
   all_pairs = [(locs[i],locs[j]) for i in range(len(locs)) for j in range(len(locs)) if i != j]
   # B + AB = 2B - A, for each (A,B) couple, we generate this point (B + AB)
   return [list_dif(list_scal_mul(p2,2),p1) for p1,p2 in all_pairs]

def _antinodes_from_locations_part2(locs,x_min,x_max):
   """Returns the list of antinodes generated by all pairs of locations given as input (as defined in part 1)"""
   # List all pairs (A,B) or (B,A) appears in the list, not both
   all_pairs = list(itertools.combinations(locs,2))
   # Compute AB vectors (as B-A)
   all_AB = [list_dif(p2,p1) for p1,p2 in all_pairs]
   # Divide by greatest common divisor so that we capture anything that is aligned with A and B (not only multiples of this vector)
   all_minAB = [list_scal_div(AB,math.gcd(AB[0],AB[1])) for AB in all_AB]
   # List all A + n * vec(AB/gcd) where n varies from -X to +Y so that the first component remains in the range (the y-component range will be dealt with later)
   return [list_add(p[0],list_scal_mul(minAB,n)) for p,minAB in zip(all_pairs,all_minAB) for n in range(int((x_min-p[0][0])/(minAB[0])), int((x_max-p[0][0])/(minAB[0]))+1)]

def _solve_problem(data_file, prob_part):
   "Function to solve the corresponding advent of code problem using the data in 'data_file'."
   _check_data(data_file)
   # Solving part 1
   with open(data_file, 'r') as f:
      f_lines = f.readlines()
      nb_lines = len(f_lines)
      nb_cols = len(f_lines[0].strip("\n"))

      # Antennas are registered by their type (i.e., char)
      antennas_per_type = {}
      for i in range(nb_lines):
         for j in range(nb_cols):
            _add_antenna(antennas_per_type,i,j,f_lines[i][j])

      # Compute all antinodes for each type (incl. out-of-bounds), depending on problem part (1 or 2)
      if prob_part == 1:
         all_antinodes_per_type = {c:_antinodes_from_locations_part1(locs) for c,locs in antennas_per_type.items()}
      else:
         all_antinodes_per_type = {c:_antinodes_from_locations_part2(locs,0,nb_cols) for c,locs in antennas_per_type.items()}

      # Aggregate all types, check that the x,y are in the range, and transform to set for only counting each entry once
      unique_antinodes = set([str(antiloc[0])+","+str(antiloc[1])
                           for c,antilocs in all_antinodes_per_type.items() for antiloc in antilocs if loc_in_range(antiloc, -1, nb_lines, -1, nb_cols)])
      total = len(unique_antinodes)
      print("Part "+str(prob_part)+" score : "+str(total))

if __name__ == "__main__":
   main()